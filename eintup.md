# Specification of Einsum Tuple language

The Einsum Tuple language consists of tensor assignment statements.  Unlike
ordinary tensors, Eintup tensors are indexed by Einsum Tuples, or 'eintups'.
An eintup represents a collection of Einstein indices in a specific order
whereever it appears.  For example, the tensor expression `params[batch,slice]`
is indexed by eintups `batch` and `slice`, in that order.  At compile time,
eintups don't have a rank or dimensions.  At execution time, they are
initialized with dimensions generated by the runtime system, and can be read
using the expressions `DIMS(batch)` and `RANK(batch)`.

## Dimensions and Rank of an Eintup

In the same way that an Einstein summation index takes on values in
some range `[0, n)`, an Eintup with `k` components takes on values in a
hyper-rectangular region `[0, n_1) x [0, n_2), ..., [0, n_k)`.  We then say
that the Eintup 'has dimensions `[n_1, n_2, ..., n_k]`'.  This is equivalent to
saying that the component-wise maximal values that it takes on are one less
than the dimensions (since the dimensions are an exclusive upper bound).
The dimensions of the Eintup determine the dimension of the array in which it
is used.  The *rank* of an Eintup is simply the number of components it has.
The rank of an array is simply equal to the sum of ranks of all indexing
expressions (Eintups or expressions of them, see below) that index the array.

## Automatic Broadcasting and Automatic Marginalization

All binary operations, including assignment, perform automatic broadcasting of
eintups that are present in just one operand.  For example, the expression

```
outer[batch,row,col] = vec1[batch,row] * vec2[batch,col]
``` 

automatically broadcasts `vec1` across eintup `col` and `vec2` across `row`.
Special to assignment, eintups which exclusively appear on the right of an
assignment will be marginalized out:

```
# day is marginalized out
monthly_totals[batch,month] = daily[batch,month,day]
```

Eintups appearing exclusively on the left of an assignment cause the right side
expression to be broadcasted across those eintups before the assignment.  For
example:

```
# ary is broadcasted across dup before assignment
outer[batch,dup] = ary[batch]
```

## Insensitivity to Index Permutation in Binary operations

Because all eintups are named, the order of eintups makes no difference until
the final assignment.  For example, the following are all legal and produce the
same result:

```
result[batch,row,col] = mat1[batch,row,inner] * mat2[inner,col,batch]
result[batch,row,col] = mat1[inner,batch,row] * mat2[col,inner,batch]
```

## Index Expressions

Eintups are the simplest kind of expression that can be used within the
brackets of a tensor.  The language accepts arbitrary *index expression*s,
which can be formed as arithmetic binary operations of Eintups and/or
integers.  Using such expressions, one can easily express notions such as
Convolution:

```
input[batch,ipos,ichan] = RANDOM(0, 10, FLOAT)
filters[fpos,ichan,ochan] = RANDOM(0, 1, FLOAT)
output[batch,opos,ochan] = filters[ipos-DIMS(stride)*opos,ichan,ochan] * input[batch,ipos,ichan]

# Alternate form
output[batch,opos,ochan] = filters[fpos,ichan,ochan] * input[batch,fpos+DIMS(stride)*opos,ichan]
```

The *index expression* in the first form of the convolution operation is
`ipos-DIMS(stride)*opos`.  Binary operations between two Eintups are
element-wise, and their ranks must match at runtime.  In the above expression,
the rank of `ipos`, `stride`, and `opos` all must match.

## Dimensions of an Index Expression

An Eintup is the simplest form of an *index expression* in the Einsum Tuple
language.  

Every index expression has a well-determined dimension at runtime.  This is
derived from the dimensions assigned to each Eintup.  When used within the
brackets of an array, the list of index expressions defines the dimension
(shape) of that array.  In the Einsum Tuple language, the first mention of the
array in the program determines its dimensions.

In the same way, the `DIMS(index_expr)` is the component-wise exclusive upper
bound (one more than the max component value) of the Eintup expression.
Calculating this for different expressions is straightforward but sometimes
counterintuitive.  For example:

```python
# This reaches a maximal value when `other` is (0, 0, ..., 0)
DIMS(tup - other) = DIMS(tup)  

# The mod operation may or may not truncate the maximal value, depending
# on the component-wise maxima of `tup` and `other`
DIMS(tup % DIMS(other)) = min(DIMS(tup), DIMS(other))

# Here, static_expr can be an integer or DIMS(other)
# All of these binary expressions follow the same logic.  Since the maximum
# value of tup is one less than DIMS(tup), we take the component-wise
# modified maximum value, and add 1 to get the exclusive upper bound
DIMS(tup // static_expr) = (DIMS(tup) - 1) // static_expr + 1
DIMS(tup //^ static_expr) = (DIMS(tup) - 1) //^ static_expr + 1
DIMS(tup * static_expr) = (DIMS(tup) - 1) * static_expr + 1
```

The full logic of dimension calculation can be found in [ast_nodes.py
SliceBinOp::dims()](https://github.com/hrbigelow/einsum-tuple/blob/40f08f1995af97eb93257d65547e7abb9aa3c9db/ast_nodes.py#L325)

## The Index Expression function FLAT()

There is (so far) a single function which accepts an index_expr_list and
returns a index expression, called `FLAT()`.







