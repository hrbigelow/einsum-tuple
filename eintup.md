# Specification of Einsum Tuple language

The Einsum Tuple language consists of tensor assignment statements.  Unlike
ordinary tensors, Eintup tensors are indexed by Einsum Tuples, or 'eintups'.
An eintup represents a collection of Einstein indices in a specific order
whereever it appears.  For example, the tensor expression `params[batch,slice]`
is indexed by eintups `batch` and `slice`, in that order.  At compile time,
eintups don't have a rank or dimensions.  At execution time, they are
initialized with dimensions generated by the runtime system, and can be read
using the expressions `DIMS(batch)` and `RANK(batch)`.

## Dimensions and Rank of an Eintup

In the same way that an Einstein summation index takes on values in
some range `[0, n)`, an Eintup with `k` components takes on values in a
hyper-rectangular region `[0, n_1) x [0, n_2), ..., [0, n_k)`.  We then say
that the Eintup 'has dimensions `[n_1, n_2, ..., n_k]`'.  This is equivalent to
saying that the component-wise maximal values that it takes on are one less
than the dimensions (since the dimensions are an exclusive upper bound).
The dimensions of the Eintup determine the dimension of the array in which it
is used.  The *rank* of an Eintup is simply the number of components it has.
The rank of an array is simply equal to the sum of ranks of all indexing
expressions (Eintups or expressions of them, see below) that index the array.

## Automatic Broadcasting and Automatic Marginalization

All binary operations, including assignment, perform automatic broadcasting of
eintups that are present in just one operand.  For example, the expression

```csharp
outer[batch,row,col] = vec1[batch,row] * vec2[batch,col]
``` 

automatically broadcasts `vec1` across eintup `col` and `vec2` across `row`.
Special to assignment, eintups which exclusively appear on the right of an
assignment will be marginalized out:

```
# day is marginalized out
monthly_totals[batch,month] = daily[batch,month,day]
```

Eintups appearing exclusively on the left of an assignment cause the right side
expression to be broadcasted across those eintups before the assignment.  For
example:

```
# ary is broadcasted across dup before assignment
outer[batch,dup] = ary[batch]
```

## Insensitivity to Relative Index Order in Binary array expressions 

The naming of Eintups allows binary array expressions to work regardless of the
relative order of indices of their operands.  For example, all three
multiplication operations below are equivalent, regardless of the relative
orders of the indices of the left and right sides of the multiplication.

```
mat1[batch,row,inner] = ... # initialization
mat2[inner,col,batch] = ... # initialization

# Define two transposed versions of mat1
m1p1[row,batch,inner] = mat1[batch,row,inner]
m1p2[row,inner,batch] = mat1[batch,row,inner]

m2p1[col,batch,inner] = mat2[inner,col,batch]
m2p2[inner,col,batch] = mat2[inner,col,batch]

# Any combination of (mat1, m1p1, m1p2) can be multiplied by (mat2, m2p1, m2p2)
# Only the combination of *sets* of indices matter, not their order
result[batch,row,col] = mat1[batch,row,inner] * mat2[inner,col,batch]
result[batch,row,col] = m1p1[row,batch,inner] * mat2[inner,col,batch]
result[batch,row,col] = m1p2[row,inner,batch] * mat2[inner,col,batch]
result[batch,row,col] = m1p1[row,batch,inner] * m2p1[col,batch,inner]
result[batch,row,col] = m1p2[row,inner,batch] * m2p2[inner,col,batch]
```

## Index Expressions

Eintups are the simplest kind of expression that can be used within the
brackets of a tensor.  The language accepts arbitrary *index expression*s,
which can be formed as arithmetic binary operations of Eintups and/or
integers.  Using such expressions, one can easily express notions such as
Convolution:

```
input[batch,ipos,ichan] = RANDOM(0, 10, FLOAT)
filters[fpos,ichan,ochan] = RANDOM(0, 1, FLOAT)
output[batch,opos,ochan] = filters[ipos-DIMS(stride)*opos,ichan,ochan] * input[batch,ipos,ichan]

# Alternate form
output[batch,opos,ochan] = filters[fpos,ichan,ochan] * input[batch,fpos+DIMS(stride)*opos,ichan]
```

The *index expression* in the first form of the convolution operation is
`ipos-DIMS(stride)*opos`.  Binary operations between two Eintups are
element-wise, and their ranks must match at runtime.  In the above expression,
the rank of `ipos`, `stride`, and `opos` all must match.

## Dimensions of an Index Expression

An Eintup is the simplest form of an *index expression* in the Einsum Tuple
language.  

Every index expression has a well-determined dimension at runtime.  This is
derived from the dimensions assigned to each Eintup.  When used within the
brackets of an array, the list of index expressions defines the dimension
(shape) of that array.  In the Einsum Tuple language, the first mention of the
array in the program determines its dimensions.

In the same way, the `DIMS(index_expr)` is the component-wise exclusive upper
bound (one more than the max component value) of the Eintup expression.
Calculating this for different expressions is straightforward but sometimes
counterintuitive.  For example:

```python
# This reaches a maximal value when `other` is (0, 0, ..., 0)
DIMS(tup - other) = DIMS(tup)  

# The mod operation may or may not truncate the maximal value, depending
# on the component-wise maxima of `tup` and `other`
DIMS(tup % DIMS(other)) = min(DIMS(tup), DIMS(other))

# Here, static_expr can be an integer or DIMS(other)
# All of these binary expressions follow the same logic.  Since the maximum
# value of tup is one less than DIMS(tup), we take the component-wise
# modified maximum value, and add 1 to get the exclusive upper bound
DIMS(tup // static_expr) = (DIMS(tup) - 1) // static_expr + 1
DIMS(tup //^ static_expr) = (DIMS(tup) - 1) //^ static_expr + 1
DIMS(tup * static_expr) = (DIMS(tup) - 1) * static_expr + 1
```

The full logic of dimension calculation can be found in [ast_nodes.py
SliceBinOp::dims()](https://github.com/hrbigelow/einsum-tuple/blob/40f08f1995af97eb93257d65547e7abb9aa3c9db/ast_nodes.py#L325)


## The Array Slice index expression

*Einsum Tuple* supports an index expression based on the idea of an array (or
tensor) slice.  To introduce it, note that a tensor of n dimensions with
integer elements may be viewed as a tensor of n-1 dimensions whose elements are
1D integer tuples of a fixed size.  For example, let's assume an integer valued
array `indices[slice,coord]`  of shapes `DIMS(slice)=[3,5]`, `DIMS(coord)=[7]`
so that the full shape of `indices` is `[3,5,7]`. We can view the tensor itself
as a function of two arguments (the component values of `DIMS(slice)`) which
outputs 7-tuples of integers. The space over which the two arguments vary are
the dimensions `[3,5]`. Just like an Eintup, the array slice is a set of
tuples, and can be used as such.  Using it as an index expression, we have:

```
indices[slice,coord] = ... # initialization
output[indices[slice,:],elem] = RANDOM(0,10,INT)
```

The index expression is `indices[slice,:]`. It is like an ordinary array
access, except that `coord` has been called with the special ":" symbol. In
order to be legal, `RANK(coord)` must equal 1, and `DIMS(coord)` must equal the
rank of the first place in the `output` array. Note that it would be perfectly
valid if the ":" were in a non-terminal position. For example, using
`indices[coord,slice]` as the array, and `indices[:,slice]` as the index
expression is also valid.

Using an array slice as an index expression is a scatter operation if used on
the left hand side, and a gather operation if on the right.

## Automatic Rank Equality Constraints

Although the `.et` files allow the user to specify rank and dims constraints
explicitly, the runtime system infers one type of constraint automatically.
Any pair of Eintups used in the same index expression will be constrained to
have the same rank.  For example, if the expression `ipos-DIMS(stride)*opos` is
used in the program, then the runtime will generate additional constraints 
`RANK(stride) = RANK(ipos)` and `RANK(opos) = RANK(ipos)`.

## An Einsum Tuple Array is sized on first use

Einsum Tuple defines the shape of an Array at the moment it first appears in
the program, which must be on the left hand side of an assignment.  The shape
is determined by the dimensions of each member of the index expression list.
Subsequent usage of the array (on the left or right) is only restricted by the
runtime in two ways.  First, that the number of index expressions used to index
it must match that in the first use.  Although one might imagine having a
rank-3 Eintup and trying to use it in place of a rank-1 and rank-2 Eintup, this
is not allowed.  Second, the index expression ranks must match those of the
first use.  For example, here is the Einsum Tuple definition of
`tf.scatter_nd`.  The Array `output` first appears on line 3, with Eintups
`dest`, `elem`.  At runtime, when the execution reaches line 3, the shape of
`output` will be determined by the dimensions of `dest` and `elem` which are
initialized before execution.  On the fourth line, the array slice index
expression `indices[slice,:]` is used in place of `dest`.  The system will
check that it has the same rank as `dest`.

```
indices[slice,coord] = RANDOM(0, DIMS(dest)[coord], INT)
updates[slice,elem] = RANDOM(0, 10, FLOAT)
output[dest,elem] = 0.0 
output[indices[slice,:],elem] = updates[slice,elem]

```

## Out of bounds index values are silently ignored

Following the previous `tf.scatter_nd` example, what happens if
`indices[slice,:]` has component values which are either negative, or greater
than the dimensions of `dist`?  When that happens, the entire assignment statement
is ignored for that setting of the Eintups.  One simpler example of this could
be trimming:

```
input[elem] = ... # initialization
trimmed[

## The Index Expression function FLAT()

There is (so far) a single function which accepts an index_expr_list and
returns a index expression, called `FLAT()`.







