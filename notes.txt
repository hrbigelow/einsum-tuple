Concepts

A 'Signature' of a Tensor is an enriched version of the notion of shape.
Whereas a shape is an ordered list of tensor dimension sizes, such as
[2,4,100,50,3], a 'signature' is a named contiguous grouping of such
dimensions, like:  { 'batch': [2,4], 'slice': [100, 50], 'coord': [3] }.
The object which stores the name and sub-shape is called the EinTup (Einstein
Tuple), and its Shape object is a container for a shape (both dimension sizes
and its rank) managed globally through the Config object.

Config::array_sig has entries representing each array.  The key is the array
name, and the value is a list of EinTups representing the signature.  During
evaluation, these EinTups are passed around through several functions to
support transpose, broadcasting, reshaping up to the signature level (one
dimension per named EinTup) or down to the individual dimension level (one
dimension per element in a EinTup shape)

It is possible for multiple EinTups to hold the same Shape instance.  This is
because, if a particular EinTup identifier is used in the context where another
one was previously defined, such as in the expression:

mat[a] = RANDOM(0, 10, FLOAT)
res[a,b] = mat[a] * mat[b]

The identifier 'b' is now used as the first index argument of array 'mat', and
so will automatically share the same shape as EinTup 'a'.  However, it will
define a separate set of dimensions for 'res' (although the dimensions are the
same shape), enabling easily generating cartesian products.

The functions AST::evaluate, flat_dims, get_inds, get_cardinality,
layout_to_sig all take / return lists of EinTups.


Constraint Logic

The constraints can be divided into two groups.  Rank-only constraints, in
which the rank of one or more EinTups are constrained.  And, Dims-containing
constraints.  The runtime automatically generates all possible combinations of
ranks in [0, 10) x N, with N being the number of primary EinTups.  It retains
only those combinations which satisfy the Rank-only constraints.

Then, it generates Dims for each, using the Dims-containing constraints.  These
constraints can be Dims-IntExpr, Dims-Rank, or Dims-Dims.  The Dims-Dims
constraints induce a graph on the set of primary EinTups, and cannot form any
cycle.  Because of this, the system is able to generate dims for each primary
EinTup using DFS on this graph.  A node (Shape) is 'visited' when its Dims are
generated via gen_dims(), and thus it returns True for has_dims().

Dims-Dims constraints must have matching rank.  However, there currently is no
clean way to determine that two such Dims have matching rank until the ranks
have been set by Runtime::cycle iterations.




Overview

The system parses the 'program' first.  The program is a list of statements.
This creates AST nodes and also registers EinTups at the moment new names are
parsed.
